---
layout: post
title: >
    Mocking frameworks are a lazy way to write bad tests that add negative value
categories: code
---

Here are some methods you might use to convince yourself that the code you've
written does something close to what it's supposed to, from most to least
effective:

1. Formally verify its correctness.
2. Write end-to-end tests against the public interface that exercise the code in
   its entirety.
3. Write unit tests against implementation details that excerise small parts of
   the code in isolation.

Of course, formal verification is generally infeasible and it can be tricky to
comprehensively cover a large codebase with end-to-end tests, but clearly it's
desirable to stay as close to the top of the list as practical.

With this in mind, I am going to explain why mocking frameworks are the worst
thing to happen to programming since [Dijkstra].

Here is a contrived example, in Python (a language you should not use, but which
is quite good for contrived examples):

{% highlight python %}
# This is the dependency. Pretend that the actual implementation of this class
# is horrendously complex, and has to write the stored values out to a database
# somewhere, and will fail if there isn't a working internet connection, and so
# on.
class ArithmeticService(object):

  def store_value(self, x):
    """Stores the value x in some sort of list of values."""
    raise NotImplementedError

  def get_sum(self):
    """Returns the sum of all the values passed to store_value() so far."""
    raise NotImplementedError

  def get_product(self):
    """Returns the product of all the values passed to store_value() so far."""
    raise NotImplementedError

# This is thing that needs testing. Nobody knows how to sum a bunch of numbers,
# so it has to use the ArithmeticService.
def sum_to(n, arithmetic_service):
  for i in range(n):
    arithmetic_service.store_value(1 + i)
  return arithmetic_service.get_sum()
{% endhighlight %}

Great. Let's use a mocking framework to test this code. Here's how one might
approach it with a made-up mocking library:

{% highlight python %}
def test_sum_to():
  mock = Mock()
  mock.store_value.expect_calls(4)
  mock.get_sum.expect_calls(1).and_return(10)
  assert sum_to(4, mock) == 10
{% endhighlight %}

Now suppose somebody spots a potential off-by-one error and mistakenly changes
the implementation of `sum_to` to this:

{% highlight python %}
# Surprise! The code is wrong, but the test still passes.
def sum_to(n, arithmetic_service):
  for i in range(n):
    arithmetic_service.store_value(i)
  return arithmetic_service.get_sum()
{% endhighlight %}

Alternatively, suppose somebody realises the implementation of `sum_to` is
hopelessly inefficient, and rewrites it like so:

{% highlight python %}
# Surprise again! The code is correct, but the test fails.
def sum_to(n, arithmetic_service):
  arithmetic_service.store_value(n)
  arithmetic_service.store_value(n + 1)
  return arithmetic_service.get_product() / 2
{% endhighlight %}

This is the fundamental problem with tests based on mock objects. Their result
gives an almost completely useless signal about whether the code under test is
actually correct or not, because it's impossible to properly encode the
semantics of the mocked-out dependency. Typically, mocking tests will break
whenever *any* non-trivial change is made to an implementation, because the
tests end up essentially being transformations of the source code that could
have been auto-generated by running it and recording what calls were made.
You may as well just hash the fucking source code and assert that it hasn't
changed since the last time.

mocks
or will not break when something is wrong (public api may change but old tests
still pass due to old fake. this is No Worse than with mocking)
doesn't really test logic
depends on implementation details
spread public api details everywhere
mocks are unstructured and express the semantics of public api all over the
place in ways like "when I pass x, I get back y"
they do two things: allow you to test method calls on dependencies (which is
almost never what you want, unless you're writing metafunctions like map or
memoize); and give you a way to inject values (which means you're testing code
against whatever you happens to say the mock does (and forgot to change) rather
than against the semantics of the dependency)
also, verify that a method *wasn't* called - even fucking worse

section about:
Tests are not a silver bullet. A crutch for cargo-cult morons. I have tests, so
I am good. Don't do any sort of cost-benefit analysis. Fuck unit tests. Pursue
tests higher up the list with real object whenever possible and fakes otherwise.
Unit tests that are shit add negative value. Do your tests ever actually catch
genuine errors or do they just perfunctorily break and have to be fixed every
time. Even worse in statically-typed languages where it isn't necessary to write
100 unit tests as a kind of poor man's type checking.

fakes
depend on public api/semantics
test behaviours
not even that much more effort and scale better (only have to write the code
*once*, not for every mock)
real tests act as a sort of specification

Here's how to test the function properly, with a fake implementation of the
`ArithmeticService`. It doesn't suffer from either problem: the test passes when
the code is correct, and fails when it's wrong.

{% highlight python %}
class FakeArithmeticService(object):
  def __init__(self):
    self.values = []
  def store_value(self, x):
    self.values.append(x)
  def get_sum(self):
    return sum(self.values)
  def get_product(self):
    return reduce(lambda a, b: a * b, self.values, 1)

def test_sum_to():
  assert sum_to(4, FakeArithmeticService()) == 10
{% endhighlight %}

don't use fucking mocks

example: lazy evaluation (in constructor vs in function). breaks

counterarguments
have to maintain fake
fake implementation may differ semantically
not good for e.g. throwing random exceptions like connection errors (true)
not good for random dependencies needed once (solve by fixing DI)
I want to test what my function calls. rarely true, for metafunctions e.g.
filter/map/cache. otherwise just grep your fucking source code.
